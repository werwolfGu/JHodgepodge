# RocketMQ事务支持

## 场景一
A(存在DB操作)、B（存在DB操作）两方需要保证分布式事务一致性，通过引入中间件MQ、A和MQ保持事务一致性(异常情况下通过MQ反查A接口实现check)
B和MQ保证事务一致(通过重试)，从而达到最终一致性；

**原理**
大事务 = 小事务 + 异步

## MQ和DB保持一致性

### 流程图

![](./picture/RocketMQ事务流程图.png)

上图为RocketMQ提供的保证MQ消息、DB事务一致性的方案。
MQ消息、DB操作一致性方案：

- 发送消息到MQ服务器，此时消息状态为SEND_OK。此消息为consumer不可见。
- 执行DB操作；DB执行成功Commit DB操作，DB执行失败Rollback DB操作。
- 如果DB执行成功，回复MQ服务器，将状态为COMMIT_MESSAGE；如果DB执行失败，回复MQ服务器，将状态改为ROLLBACK_MESSAGE。注意此过程有可能失败。
- MQ内部提供一个名为“事务状态服务”的服务，此服务会检查事务消息的状态，如果发现消息未COMMIT，
则通过Producer启动时注册的TransactionCheckListener来回调业务系统，业务系统在
checkLocalTransactionState方法中检查DB事务状态，如果成功，则回复COMMIT_MESSAGE，否则回复ROLLBACK_MESSAGE。
>说明：
上面以DB为例，其实此处可以是任何业务或者数据源。
以上SEND_OK、COMMIT_MESSAGE、ROLLBACK_MESSAGE均是client jar提供的状态，在MQ服务器内部是一个数字。
TransactionCheckListener 是在消息的commit或者rollback消息丢失的情况下才会回调（上图中灰色部分）。这种消息丢失只存在于断网或者rocketmq集群挂了的情况下。当rocketmq集群挂了，如果采用异步刷盘，存在1s内数据丢失风险，异步刷盘场景下保障事务没有意义。所以如果要核心业务用Rocketmq解决分布式事务问题，建议选择同步刷盘模式。

## 多系统数据一致性(多事务)

### 流程图

![](./picture/交易系统.png)

多方事务

当需要多方系统保证数据一致性(多余2个)，前面提到的两方事务一致性已经无法支持了；这是需要引入TCC模式


以上图交易系统为例

- 交易系统创建订单（往DB插入一条记录），同时发送订单创建消息。通过RocketMq事务性消息保证一致性
- 接着执行完成订单所需的同步核心RPC服务（非核心的系统通过监听MQ消息自行处理，处理结果不会影响交易状态）。
- 执行成功更改订单状态，同时发送MQ消息。
- 交易系统接受自己发送的订单创建消息，通过定时调度系统创建延时回滚任务（或者使用RocketMq的重试功能，设置第二次发送时间为定时任务的延迟创建时间。在非消息堵塞的情况下，消息第一次到达延迟为50ms左右，这时可能RPC还未执行完，订单状态还未设置为完成，第二次消费时间可以指定）。
延迟任务先通过查询订单状态判断订单是否完成，完成则不创建回滚任务，否则创建。 PS：多个RPC可以创建一个回滚任务，通过一个消费组接受一次消息就可以；也可以通过创建多个消费组，一个消息消费多次，每次消费创建一个RPC的回滚任务。  回滚任务失败，通过MQ的重发来重试。



