# redis过期策略
## redis过期策略
- 通常过期策略有三种
    - 定时过期
      
        每个设置过期时间的key都设置一个定时器，到过期时间立即清除；
        - 好处：对内存友好，
        - 坏处：占用大量内存；
    - 惰性删除
    
        不会主动删除过期KEY，而是在访问该KEY时进行检查，如果KEY已经过期，redis会删除，然后返回 `NULL` 给客户端；
        - 好处：这种方法的优点是节省了CPU资源，因为只有在访问时才检查是否已经过期；
        - 坏处：如果一个过期KEY长时间内没有被访问，它将继续占用内存，可能导致内存泄漏；
        
    - 定期删除
      
        redis会定期检查并删除过期KEY ，这是一个通过后台的任务实现，该任务会随机抽取一些设置了过期时间的KEY进行检查；
        
        - 优点：可以删除那些未被访问过的过期KEY ，避免内存浪费；
        - 会占用一部分CPU资源，尤其是过期KEY较多时，可能会影响服务器性能；

> redis 使用了惰性过期和定期过期；
> 为何要使用这2中过期策略：在提高redis的服务性能（CPU性能）与内存管理的平衡；
>
> 每秒检查过期KEY的次数：默认是`10`次；
>
> redis的定期删除策略中，每次随机抽取的KEY的数量通常是 默认是20 ； 这意味着redis会每隔一定时间从设置了过期时间的KEY中随机选取20 个建进行检查，如果发现这些KEY 过期，则将他们删除； 如果这20个随机抽取的KEY中，过期KEY的数量超过了一定比例（默认是`25%`）,则redis会继续执行下一轮随机抽取和检查过程；直到连续2轮抽查中么有超过这个阈值（`25%`）;
>
> 过期字典：redis维护了一个字典（hash table），用于存储所有设置了过期时间的KEY的`指针` 和他们的`过期时间`；

## redis淘汰策略

Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。

1. **noeviction**：这是默认策略，当内存使用达到 `maxmemory` 限制时，Redis 不会进行任何淘汰操作，新写入的命令会返回错误。
2. **allkeys-lru**：从所有键中选择最近最少使用的键进行淘汰。
3. **volatile-lru**：从设置了过期时间的键中选择最近最少使用的键进行淘汰。
4. **allkeys-random**：从所有键中随机选择键进行淘汰。
5. **volatile-random**：从设置了过期时间的键中随机选择键进行淘汰。
6. **volatile-ttl**：从设置了过期时间的键中选择即将过期的键进行淘汰。
7. **allkeys-lfu**：从所有键中选择最不经常使用的键进行淘汰。
8. **volatile-lfu**：从设置了过期时间的键中选择最不经常使用的键进行淘汰。

这些策略可以通过配置文件中的 `maxmemory-policy` 指令设置，或者在运行时通过 `CONFIG SET` 命令动态更改。选择合适的内存淘汰策略取决于具体的应用场景和业务需求。例如，如果数据的热点访问模式明显，使用 LFU 策略可能更合适；而对于需要保证数据新鲜度的场景，使用 TTL 策略可能更合适。
