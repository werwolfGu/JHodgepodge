# 学习总纲

## 目录
- [Java](#java)
    - [Java集合](#Java集合)
    - [Java多线程](#Java多线程)
    - [threadlocal](./threadLocal.MD)  
    - [jvm](#JVM内存结构GC算法)
    - [lock](Java锁)
- [MySQL](#MySQL)
  - [事务隔离级别](#事务隔离级别)
  - [MVCC](./MySQL/MySQL-MVCC.MD)  
  - [MySQL日志文件](./MySQL/MySQL日志文件.MD)
  - [执行计划分析](./MySQL/explain.MD)
  - 锁 间隙锁
  - 索引存储结构
  - [索引下推 索引覆盖  回表](#索引下推、索引覆盖、回表)
- redis
    1. [redis数据结构  string  hash  list  set zset](./redis/redis-数据结构.MD) 
    2. redis内部数据结构：实现原理
    3. [redis失效策略](./redis/redis过期以及淘汰策略.MD#redis过期策略)
    4. [redis缓存淘汰策略](./redis/redis过期以及淘汰策略.MD#redis淘汰策略)
    5. [redis持久化策略](./redis/redis持久化策略.MD)
    6. [redis渐进式hash](./redis/渐进式rehash.MD)
    7. redis如何实现分布式锁 ; 
    8. redis如何保证高性能；
- RocketMQ
    1. rocketMQ消息有哪几种
    2. rocketMQ如何保证事务
    3. rocketMQ如何实现消息不丢失
    4. 为何要使用rocketMQ
    5. rocketMQ消息消费异常如何处理
    6. rocketMQ如何保证幂等
- 网络IO-多路复用
    1. poll select epoll 实现原理
- 进阶
    1. 服务器CPU飚高如何排查；
    2. 内存溢出问题如何排查 -mat 什么情况下会出现内存溢出
    3. 系统稳定性
    4. [arthas](https://arthas.aliyun.com/doc/)
    5. spring IOC AOP
    6. Mybatis
    7. 缓存技术  
       - 缓存穿透
       - 缓存击穿 
       - 缓存雪崩
    8. 高可用、高性能、可扩展
    9. [接口幂等实现](#接口幂等实现)
    10. [唯一性ID如何生成](#唯一性ID如何生成)
        - snowflakes(雪花算法)
        - 数据库实现 (步长)
    11. 负载均衡算法
        - 轮询
        - 一致性hash
        - 随机数
        - 最少使用算法
    12. 限流算法
        - 滑动窗口
        - 漏桶
        - 令牌桶
        - 计数法
    13. 团队管理
    14. traceId解决方案
    15. 分库分表
    16. 接口：限流、降级、熔断；   
        (RateLimiter / 开关降级  / sentinel)
    17. 分布式锁
        - redis实现分布式锁（lua脚本实现）； watchdog
        - 数据库唯一版本号
        - 数据库乐观锁(版本号)
        - zookeeper实现
    18. [系统稳定性保障](#系统稳定性保障)
- 自研框架
  - 流程引擎
    - [开源LiteFlow](https://gitee.com/dromara/liteFlow)
  - 规则引擎
  - 日志链
  - 工程中jar冲突，类冲突maven插件工具
  - 去O过程中实现DB双写能力；



## Java集合

> 常用java集合类有 `ArrayList` `LinkedList` `HashMap` `ConcurrentHashMap` `HashSet` 等；



## MySQL 

### 事务隔离级别

MySQL 有四种事务隔离级别 `读未提交` `读已提交` ` 可重复读` `串性化` MySQL默认事务隔离方式 `可重复读`

| 事务隔离级别 | 脏读  | 不可重复读  | 幻读  |  
|--------|-----|--------|-----|
| 读未提交   | 是   | 是      | 是   |
| 读已提交   | 否   | 是      | 是   |
| 可重复读   | 否   | 否      | 是   |
| 串行化    | 否   | 否      | 否   |

- 脏读  
  `事务A`做`update`操作在事务未提交的情况下，`事务B`能 `select`出`事务A`未提交的数据；
- 不可重复读 
  - **事务A** 开始后做`update` 操作；
  - **事务B** 开始事务，`select` 此时是不会读到**事务A**的`update`；
  - **事务A** commit；
  - **事务B** 再次`select`操作，读到了**事务A**的commit；
- 幻读  
  **事务B** 能读到 **事务A** 的 `insert`操作；

### 执行计划分析

expain出来的信息有10列，
分别是`id`、`select_type`、`table`、`type`、`possible_keys`、`key`、`key_len`、`ref`、`rows`、`Extra`，下面对这些字段进行解释：

- id  
  执行编号，标识select所属的行。如果在语句中没子查询或关联查询，
  只有唯一的select，每行都将显示1。
  否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置

- select_type  
  显示本行是简单或复杂select。
  如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT）;

- table   
  访问引用哪个表（引用某个查询，如“derived3”）

- type  
  数据访问/读取操作类型（ALL、index、range、ref、eq_ref、const/system、NULL）

- possible_keys  
  揭示哪一些索引可能有利于高效的查找

- key  
  显示mysql决定采用哪个索引来优化查询

- key_len  
  显示mysql在索引里使用的字节数

- ref  
  显示了之前的表在key列记录的索引中查找值所用的列或常量

- rows  
  为了找到所需的行而需要读取的行数，估算值，不精确。
  通过把所有rows列值相乘，可粗略估算整个查询会检查的行数

- Extra  
  额外信息，如using index、filesort等


### id

>1. id相同时，执行顺序由上至下，内存会认为三个表，乘积小的先执行
      比如三个表：t3-t4-t5
      ：t3-t3-t4
>2. 如果是子查询，id的序号会递增，`id值越大优先级越高，越先被执行`
>3. id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行

```shell
mysql> explain select * from (select * from ( select * from t3 where id=123) a) b;  
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+  
| id | select_type | table      | type   | possible_keys     | key     | key_len | ref  | rows | Extra |  
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+  
|  1 | PRIMARY     | <derived2> | system | NULL              | NULL    | NULL    | NULL |    1 |       |  
|  2 | DERIVED     | <derived3> | system | NULL              | NULL    | NULL    | NULL |    1 |       |  
|  3 | DERIVED     | t3         | const  | PRIMARY,idx_t3_id | PRIMARY | 4       |      |    1 |       |  
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+

```

### type

>system、const、eq_reg、ref、range、index、ALL（从左到右，性能从好到差）

- ALL  
  全表扫描

- index
  索引全表扫描

- range  
  索引范围查询

>当使用=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range

- ref  
  触发条件：
    - 触发联合索引最左原则 ;
    - 或者这个索引不是主键，也不是唯一索引（换句话说，如果这个在这个索引基础之上查询的结果多于一行）。

>在对已经建立索引列进行 = 或者 <=> 操作的时候，ref会被使用到


- eq_ref  
  和ref类似 不过  `eq_ref` 是 `主键索引`或`唯一索引`；

- const
  当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。

- system  
  当查询的表只有一行数据；

## 索引下推 索引覆盖  回表
> 如表 user  有如下列  id name age 
### 回表

```sql
select * from user where name='gce'
```
所谓回表，比如通过普通索引查询表数据时，查询出来后，需要通过主键ID再次去查询一次；  
比如：如上SQL 通过name(普通索引)查询一次后，查询到的是主键ID，通过主键ID再一次查询获取到需要的数据；
### 索引覆盖
```sql
select name,age from user where name='gce'
```
如上SQL直接在索引中就能返回需要的值，就不需要回表了，这就是索引覆盖；(name,age) 联合索引

### 索引下推
```sql
select * from user where name like 'gce%' and age='18';
```
如上SQL创建了联合索引(name , age) 根据索引最左匹配原则会走索引，MySQL 5.6 后name查询到后会再根据age查询是否满足18 然后再回表；



#### 接口幂等实现

1. **唯一事务编号**：
   对于每个操作请求，客户端生成一个唯一的事务ID。服务器在处理前检查该ID是否已经存在，如果存在，则不再执行操作，直接返回之前的结果。比如将数据存在redis或数据库中；
2. **乐观锁**：
   在数据库操作中，使用乐观锁可以通过比较数据版本号来实现幂等性。在更新前检查版本号，如果不一致则不进行更新。
3. **悲观锁**：
   数据库中通过行锁或表锁来确保同一时间只有一个操作能修改数据。
4. **状态机**：
   将数据变更操作建模为一个状态机，每种状态下只有特定的操作可以执行。如果状态不允许，操作将被拒绝。
5. **请求去重**：
   服务器存储已经处理的请求的指纹信息，比如请求参数的Hash值。当收到重复请求时，通过比对指纹信息识别并丢弃。
6. **幂等Token**：
   类似于唯一事务编号，服务器提供一个Token，客户端在执行操作时带上这个Token，服务器通过Token确保操作只被执行一次（例如：**snowflake 雪花算法**，**美团 Leaf 算法**，**滴滴 TinyID 算法**，**百度 Uidgenerator 算法**，**uuid**，**redis** 等）
7. **预写日志**：
   写入一项记录到日志中，表明某项操作即将执行。如果操作失败而需要重试，日志可以用来检查操作是否已经执行过。

#### 唯一性ID如何生成

现在市面上主流的唯一ID生成框架：

1. **snowflake 雪花算法**
2. [**美团 Leaf 算法**](https://github.com/Meituan-Dianping/Leaf)
3. [**滴滴 TinyID 算法**](https://github.com/didi/tinyid)
4. **百度 Uidgenerator 算法**

#### 系统稳定性保障：

[系统稳定性最佳实践](./规划/系统稳定性最佳实践.md)

事前预防预警
	1. 稳定性架构设计  架构的 高性能、高并发、高可用、可扩展，
	2. 防御式编程  ----外部系统不能相信；确保外部系统出问题时，系统需要有应对方式；
	3. 业务可降级  sentinel 
	4. 力保核心链路     ----限流   sentinel
	5. 慢SQL/接口优化   索引优化 SQL优化
	6. 日常巡检        监控  ---业务监控  系统监控
	7. 灰度发布
	8. 业务指标监控
	9. 系统指标监控
	10. 全链路压测
	11. 限流等
	12. 蓝绿发布：对比组；

事中快速止损
	刚上线则快速回滚、及时周知上级及相关业务方、降级开关、限流等，关键思路是先止损而不是纠结于问题。
事后复盘总结
	找出问题根源、5whys分析法、制定相应的优化措施、组织团队进行复盘
	

	为什么会发生
	为什么没有发现
	为什么没有从系统上预防事故


PM 常见的职责如下：

1）协调各端人员进行需求评审。
2）排期：协调好各端进行排期评估，预留各端人员时间资源，做好总体排期、里程碑设定。
3）约定项目沟通机制：根据项目判断是否需要统一项目室开发、各端之间如何同步进展及问题，如遇项目风险，及时向PM反馈，PM可联合讨论，确定最终方案。
4）把控项目进度：及时了解各端的进度，及时了解项目风险（进度缓慢、人员请假等），及时与产品和业务沟通协调，及时作出风险应对。
5）需求变更控制：项目立项后，所有的需求变更，不得在原需求文档上进行修改。如需修改，需要与PM沟通确认。需求统一交给PM，由PM沟通后邮件通知项目组成员。
6）质量控制：接口提供者，在项目联调前需要保证主体功能OK；各端在联调前做好自测；QA测试时保证环境稳定，不要随意部署。
7）同时作为后端负责人：进行详细的需求分析和拆解，安排好后端人员的开发，做好codereview、方案设计。
8）项目结束后及时进行总结，观察项目目标达成情况，及时进行复盘。

9） 3P1T (person project product- techonlogy)

#### 工作中总结

1. 对于应用程序层面：保证应用一次完成的链路可以通过一个traceId查询出所有的链路；
2. 通过注解实现开关拿开关； 不会再出现各种各样的拿开关的代码
3. 使用redis实现延时队列使用zset实现
4. 使用redis实现at least once queue
5. 对于数据库中突然某条SQL跑慢了，应该是执行计划跑偏了 ；绑定执行计划； MySQL指定索引；
6. 对于大数据量跑数据 源数据使用 ID分段 ；在分布到集群中个节点执行；
7. 开始pom插件工具判断相同类在不同jar中出现的情况；

   做的业务：信用卡积分主流程；
   积分笔笔抽 ；
   **对于恶意薅羊毛的客户实施积分账号冻结；**