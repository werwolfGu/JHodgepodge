#MySQL

## 目录

- [MySQL事务](#MySQL事务)

- [MySQL间隙锁](#间隙锁)

- [执行计划explain](#MySQL执行计划)

## MySQL事务 
MySQL默认的事务隔离级别为：`可重复读`
- 未提交读   `脏读`  
    - A事务开始查询数据
    - B事务更新数据但未提交
    - A事务重新查询但是查询到了B事务更新的数据
    
- 已提交读  `重复读`
    - A事务开始 查询数据
    - B事务更新数据 同时提交了
    - A事务重新查询数据 查询到了B事务更新并提交的数据
    
- 可重复读   `幻读`
    - A事务开始 查询数据
    - B事务插入一条数据 同时提交了
    - A重新查询数据 查询到B事务插入的数据
    
- 串行化

## MVCC实现

MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

下面看一下在 REPEATABLE READ 隔离级别下，MVCC 具体是如何操作的：

- SELECT：

    InnoDB 会根据以下两个条件检查每行记录：
    InnoDB 只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
    行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。只有符合上述两个条件的记录，才能返回作为查询结果
- INSERT：
    InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。
- DELETE：
    InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。
- UPDATE：
    InnoDB 插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作

## MySQL锁

MySQL的锁机制分别为： `表级锁` `页级锁` `行级锁`

- 表级锁
    表级别的锁定是 MySQL 各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。
    
    所以获取锁和释放锁的速度很快。由于表级锁定一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。
    
    当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。
    
    使用表级锁定的主要是 MyISAM，MEMORY，CSV 等一些非事务性存储引擎。
  
- 页级锁
    页级锁定是 MySQL 中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。
    
    页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。
    
    在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。
    
    不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。使用页级锁定的主要是 BerkeleyDB 存储引擎
    
- 行级锁

    行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。
    
    由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。
    
    虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。
    
    由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。
    
    此外，行级锁定也最容易发生死锁。使用行级锁定的主要是 InnoDB 存储引擎。
    
    
总的来说，MySQL 这三种锁的特性可大致归纳如下：

**表级锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

**行级锁**：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

**页面锁**：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。


MySQL 的表级锁有两种模式：

- 表共享读锁（Table Read Lock）
- 表独占写锁（Table Write Lock）

锁模式的兼容性：

对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求。   
对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作。     
MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。


总结：表锁，读锁会阻塞写，不会阻塞读。而写锁则会把读写都阻塞。

## MySQL执行计划

参考:cnblogs.com/songwenjie/p/9409852.html



参考：
https://www.cnblogs.com/songwenjie/p/9415016.html

https://dev.mysql.com/doc/refman/5.7/en/explain-output.html